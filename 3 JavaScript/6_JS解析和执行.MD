## 6_JS解析和执行

### 1 解析过程

（一）**对于代码的全局处理**：总体分为预处理和执行两个阶段
- 1 预处理阶段：
	- 读取分析整个源代码，创建词法环境（全局为`window`对象）
	- 先扫描函数声明（**声明方式声明的**），再扫描变量声明(`var`)
	- 将扫描到的函数和变量保存到词法环境中
	- 注：
		- 变量的值声明为`undefined`，函数的值则为引用，指向该函数
		- 命名冲突处理：
			- 处理函数声明有冲突时，后者会覆盖
			- 处理变量声明有冲突时，会忽略
			- 混合时，按CSS权重理解，函数权重更大

- 2 执行阶段：
	- 从上到下依次执行，碰到全局词法下有的覆盖其值，没有的则加入全局词法

（二）**对于函数代码的处理**：基本类似代码的全局处理
- 1 预处理阶段：
	- 读取分析整体代码，创建词法环境，将函数的**参数**添加至词法环境
	- 先扫描内部函数的声明，再扫描变量声明（`var`）
	- 将扫描到的函数和变量保存到词法环境中
- 2 执行阶段：同上

### 2 执行过程-事件循环 
[参考链接](https://juejin.im/post/59e85eebf265da430d571f89)

- **基础**：由于JS是单线程，则同时只能有一个任务被执行，任务可以分成同步任务和异步任务两类

- **定义**：
	- 同步任务和异步任务分别进入不同的执行场所
	- 同步任务直接进入主线程
	- 异步任务进入`Event Table`并注册回调函数
	- 当指定的事情完成后，`Event Table`会将其对应的回调函数转入`Event Queue`
	- 当主线程任务执行完毕为空时，会从`Event Queue`中读取相应的函数进入主线程执行（由JS引擎中的`monitoring process`监控）
	- 以上过程不断重复，即为事件循环（`Event Loop`）

- **实例**：
	- `setTimeout`：用于延时执行；`setInterval`：用于循环执行
	- 由于两者都为异步的，因此如果主线程中存在执行时间较长的任务，会阻塞其执行
	```
	setTimeout(() => {console.log('hi');}, 3000)  // 延时3秒执行
	setInterval(() => {console.log('hi');}, 3000)  // 每隔3秒执行，注：每隔3秒，console.log进入Event Queue
	```
	
### 3 执行过程-宏任务和微任务
- **定义**：
	- 宏任务（macro-task）：包括整体代码script，setTimeout，setInterval
	- 微任务（micro-task）：Promise，process.nextTick（node中的setTimeout）

- **说明**：
	- 不同类型的任务会进入对应的`Event Queue`
	- setTimeout，setInterval的回调函数会进入宏任务的`Event Queue`
	- Promise，process.nextTick的回调函数会进入微任务的`Event Queue`

- **事件循环的顺序**：
	- 整体代码(宏任务)进入，开始第一次循环
	- 找到一个宏任务队列执行完毕
	- 执行所有的微任务`Event Queue`
	- 再次从宏任务开始
